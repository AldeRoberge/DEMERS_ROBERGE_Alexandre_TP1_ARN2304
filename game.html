<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        .game-canvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
        }

        .dialog {
            background-color: #161616;
        }
    </style>

</head>
<body onload="startGame()">


<script>

    const worldObjects = [];

    let myGamePiece;

    let objectSpawner;

    const gameUpdateRate = 1;

    // Sounds
    var hurtSound;
    var healSound;
    var deathSound;
    var goldSound;

    var music;

    let phaseHandler;

    // World scroll
    var isWorldScrolling = true;

    function startGame() {
        myGamePiece = new PlayerObject(gameWidth / 2, gameHeight / 2);

        myGameArea.start();

        objectSpawner = new StarSpawner();

        hurtSound = new Audio("audio/hurt.wav");
        healSound = new Audio("audio/heal.wav");
        goldSound = new Audio("audio/gold.wav");
        deathSound = new Audio("audio/death.wav");

        music = new Audio("audio/music.mp3");

    }

    var isGamePaused = false;

    var score = 0;
    var scoreCountText;

    var gold = 0;
    var goldCoinsText;

    // Game is ended, player has no more health
    var gameEnd = false;

    var maxHealth = 20;
    var currentHealth = 0;

    let drawHealthBar = false;

    // Goes from 255 to 0 to show player hurt (255 = white, 0 = red (hurt))
    let damageIndicator = 255;

    // The player is hurt / damaged
    function HitPlayer(damage) {
        damageIndicator = 0; // See Player update method
        currentHealth -= damage;

        hurtSound.play();

        if (currentHealth < 0) {
            deathSound.play();
            gameEnd = true;
            ShowCursor(true);
            setDialog("");
        }
    }

    // The player is healed
    function HealPlayer(heal) {
        damageIndicator = 255;

        healSound.play();

        currentHealth += heal;

        if (currentHealth >= maxHealth) {
            currentHealth = maxHealth;
        }
    }

    function CollectGold(number) {
        gold += number;

        goldSound.play();
    }



    window.addEventListener("click", go);

    let isGameStarted = false;

    function go() {

        if (!isGameStarted) {
            isGameStarted = true;
            music.play();

            ShowCursor(false);

            const showTextDelay = 1000;

            new UIText(gameWidth / 2, gameHeight / 2, "Les Jeux Perigno Maximus", "25px Georgia", "white", showTextDelay);
            new UIText(gameWidth / 2, gameHeight / 1.85, "prÃ©sentent", "20px Georgia", "white", showTextDelay);

            setTimeout(function () {

                let textShowLength = showTextDelay * 1.5;

                var text = new UIText(gameWidth / 2, gameHeight / 2, "S. T. A. R. S.", "40px Arial", "white", textShowLength);

                setTimeout(function () {
                    beginGame();
                }, textShowLength);

            }, showTextDelay);



        }



    }


    function beginGame() {

        const stopBlinkingTime = 800;

        // Shows the score
        goldCoinsText = new UIText(gameWidth - 100, 50, "Gold : " + gold, "30px Arial", "white", -1);
        goldCoinsText.blink(true);

        scoreCountText = new UIText(100, 50, "Score : " + score, "30px Arial", "white", -1);
        scoreCountText.blink(true);

        setTimeout(function () {
            scoreCountText.blink(false);
            goldCoinsText.blink(false);

            phaseHandler = new PhaseHandler();

            drawHealthBar = true;


        }, stopBlinkingTime);
    }

    var gameWidth = 1200;
    var gameHeight = 800;

    var myGameArea = {
        canvas: document.createElement("canvas"),
        start: function () {

            this.canvas.width = gameWidth;
            this.canvas.height = gameHeight;


            this.context = this.canvas.getContext("2d");
            document.body.insertBefore(this.canvas, document.body.childNodes[0]);

            setInterval(updateGameArea, gameUpdateRate);

            window.addEventListener('mousemove', function (e) {
                myGameArea.x = e.pageX;
                myGameArea.y = e.pageY;
            })
        },
        clear: function () {
            this.context.fillStyle = "black";
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }

    function ShowCursor(b) {

        if (b) {
            myGameArea.canvas.style.cursor = "auto"; //hide the original cursor
        } else {
            myGameArea.canvas.style.cursor = "none"; //hide the original cursor
        }

    }

    function UIText(x, y, text, font, color, destroyAfter) {

        let displayText = text;

        let timeLived = 0;

        this.setText = function (text) {
            displayText = text;
        }

        this.blink = function (isBlinking) {
            this.isBlinking = isBlinking;
        }

        const blinkTimeLength = 100;

        let blinkTime = 0;

        this.update = function (gameTick, ctx) {

            timeLived += gameTick;

            if (destroyAfter > 0 && timeLived > destroyAfter) {
                console.log("Destroyed text.");

                // Destroy this object
                worldObjects.splice(worldObjects.indexOf(this), 1);
            }

            blinkTime += gameTick;

            if (blinkTime > blinkTimeLength * 2) {
                blinkTime = 0;
            }

            if (this.isBlinking && blinkTime > blinkTimeLength) {
                return;
            }

            ctx.textAlign = "center";
            ctx.fillStyle = color;
            ctx.font = font;
            ctx.fillText(displayText, x, y);
        }

        worldObjects.push(this);

    }

    function PlayerObject(x, y) {

        // The final size of the player
        let losangeEndSize = 20;

        // The size of the player
        let losangeSize = 500;

        this.x = x;
        this.y = y;

        this.update = function (gameTick, ctx) {

            losangeSize -= gameTick;

            if (losangeSize <= losangeEndSize) {
                losangeSize = losangeEndSize;
            }

            // Draw the main triangle

            if (damageIndicator < 255) {
                damageIndicator += 1;
            }

            ctx.fillStyle = "rgb(255," + damageIndicator + "," + damageIndicator + ")";


            // LIMIT THE X AND Y SO THE PLAYER DOES NOT GO AWAY FROM THE CANVAS

            // Clamp X
            if (this.x < 20) {
                this.x = 20;
            } else if (this.x > gameWidth - 20) {
                this.x = gameWidth - 20;
            }

            // Clamp Y
            if (this.y < 20) {
                this.y = 20;
            } else if (this.y > gameHeight - 20) {
                this.y = gameHeight - 20;
            }

            /**
             *
             * YOU'RE BOUND TO THIS PRISON SHELL, SLAVE
             *
             */

            ctx.beginPath();
            ctx.moveTo(this.x, this.y - losangeSize);
            ctx.lineTo(this.x - losangeSize, this.y + losangeSize);
            ctx.lineTo(this.x + losangeSize, this.y + losangeSize);
            ctx.fill();

            // Draw the red propellers

            ctx.fillStyle = "red";

            ctx.beginPath();
            ctx.moveTo(this.x - losangeSize, this.y + losangeSize);
            ctx.lineTo(this.x - (losangeSize / 2), this.y + losangeSize * 2);
            ctx.lineTo(this.x, this.y + losangeSize);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(this.x + losangeSize, this.y + losangeSize);
            ctx.lineTo(this.x + (losangeSize / 2), this.y + losangeSize * 2);
            ctx.lineTo(this.x, this.y + losangeSize);
            ctx.fill();

            // Draw the orange (flickering) propellers

            ctx.fillStyle = "orange";

            const flickeringHeight = this.y + (losangeSize * 2) - (Math.random() * 15) - 0.25;

            ctx.beginPath();
            ctx.moveTo(this.x - losangeSize, this.y + losangeSize);
            ctx.lineTo(this.x - (losangeSize / 2), flickeringHeight);
            ctx.lineTo(this.x, this.y + losangeSize);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(this.x + losangeSize, this.y + losangeSize);
            ctx.lineTo(this.x + (losangeSize / 2), flickeringHeight);
            ctx.lineTo(this.x, this.y + losangeSize);
            ctx.fill();


            // Draw the healthbar
            if (drawHealthBar) {
                const sizeFactor = 2;
                const barSize = maxHealth * sizeFactor;

                ctx.fillStyle = "red";
                ctx.fillRect(this.x - barSize / 2, this.y + losangeSize * 2.5, barSize, 10);

                ctx.fillStyle = "green";
                ctx.fillRect(this.x - barSize / 2, this.y + losangeSize * 2.5, currentHealth * sizeFactor, 10);
            }


        }
    }

    function StarSpawner() {

        const spawnStarTime = 10;
        let spawnStarIndex = 0;

        this.update = function (tickDelta) {
            spawnStarIndex += tickDelta;

            if (spawnStarIndex > spawnStarTime) {
                spawnStarIndex = 0;

                const starRadius = 1;
                const x = Math.random() * gameWidth;
                const y = -(starRadius / 2);
                worldObjects.push(new Star(x, y, starRadius));
            }
        }

        worldObjects.push(this);
    }

    function TextPhase(phaseHandler, text, textColor, font, time) {

        this.start = function () {
            console.log("Started text phase...");
            setDialog(text, font, textColor);
        }

        let tickIndex = 0;

        this.update = function (tickDelta) {

            tickIndex += tickDelta;

            if (tickIndex > time) {
                clearDialog();
                phaseHandler.nextPhase(1000);
            }
        }


    }


    function IntroPhase(enemies, phaseHandler, text, textColor, font) {

        this.start = function () {
            console.log("Started intro phase...");

            setDialog("Your mission stars now.", "13px Arial", "red");
        }

        let tickIndex = 0;

        this.update = function (tickDelta) {

            tickIndex += tickDelta;

            if (tickIndex > 1000) {
                tickIndex = 0;

                const x = GetRandomObjectSpawnPositionX();
                worldObjects.push(new HealObject(x, -5));


                phaseHandler.nextPhase(1000);

            }
        }
    }

    function RecompensePhase(heal, gold, phaseHandler) {

        this.start = function () {
            console.log("Started recompense phase...");
        }

        this.update = function (tickDelta) {

            isWorldScrolling = false;

            heal--;
            gold--;

            if (heal > 0) {
                const x = GetRandomObjectSpawnPositionX();
                const y = GetRandomObjectSpawnPositionY();

                worldObjects.push(new HealObject(x, y));
            }

            if (gold > 0) {
                const x = GetRandomObjectSpawnPositionX();
                const y = GetRandomObjectSpawnPositionY();

                worldObjects.push(new GoldObject(x, y));
            }

            if (heal < 0 && gold < 0) {
                setDialog("")

                phaseHandler.nextPhase(2000);
            }

        }
    }


    function EasyPhase(enemies, phaseHandler, spawnTime, message, color, enemySpeed, waveLength) {

        this.start = function () {
            console.log("Started easy phase...");

            setDialog(message, color, "13px Arial");
        }

        let tickIndex = 0;

        let tickCount = 0;

        this.update = function (tickDelta) {

            tickIndex += tickDelta;

            if (tickIndex > spawnTime) {

                tickCount++;

                tickIndex = 0;

                const x = GetRandomObjectSpawnPositionX();
                worldObjects.push(new Enemy(x, -20, 20, 1, enemySpeed));
            }

            if (tickCount > waveLength) {
                setDialog("")
                phaseHandler.nextPhase(500);
            }

        }
    }

    function GetRandomObjectSpawnPositionX() {
        return Math.random() * gameWidth;
    }

    function GetRandomObjectSpawnPositionY() {
        return Math.random() * gameHeight;
    }

    function FeelMyWrathPhase(enemies, phaseHandler, text, textColor, font) {

        this.phaseHandler = phaseHandler;
        this.enemies = enemies;

        let tickIndex = 0;

        this.start = function () {
            setDialog(text, textColor, font);
        }

        let tickCount = 0;

        this.update = function (tickDelta) {

            score++;

            tickIndex += tickDelta;

            if (tickIndex > 10) {

                tickCount++;

                tickIndex = 0;

                const x = GetRandomObjectSpawnPositionX();
                worldObjects.push(new Enemy(x, -5, 10, 1, 1));
            }

            if (tickCount > 1000) {


                phaseHandler.nextPhase(1000);
            }

        }
    }

    function PhaseHandler() {

        let currentPhaseIndex = -1;

        let phase0 = new IntroPhase(100, this);
        let phase1 = new EasyPhase(100, this, 50, "Be warned of the dangers.", "green", 0.75, 30);
        let phase2 = new TextPhase(this, "Good job!", "Red", "30px Arial", 3000);
        let phase3 = new EasyPhase(100, this, 100, "You're doing good!", "yellow", 1, 20);
        let phase4 = new EasyPhase(100, this, 100, "Keep going!", "orange", 1.5, 10);
        let phase5 = new FeelMyWrathPhase(100, this, "FEEL MY WRATH!!!", "red", "30px Arial");
        let phase6 = new RecompensePhase(10, 10, this);
        let phase7 = new EasyPhase(100, this, 100, "Let's see...", "yellow", 1, 20);

        let isInBetweenPhases = false;
        let timeBeforeNextPhase = 0;

        this.nextPhase = function (delay) {
            setDialog("");
            isInBetweenPhases = true;
            timeBeforeNextPhase = delay;
        }

        this.update = function (tickDelta) {

            if (isInBetweenPhases) {

                if (timeBeforeNextPhase > 0) {
                    // Wait for next phase...
                    timeBeforeNextPhase -= 1;
                } else {
                    // Ready for next phase
                    isInBetweenPhases = false;
                    currentPhaseIndex++;
                    GetCurrentPhase().start();
                }

                return;
            }

            isWorldScrolling = true;

            GetCurrentPhase().update(tickDelta);

        }

        // TODO
        //this.nextPhase(1000);
        this.nextPhase(1);

        function GetCurrentPhase() {
            switch (currentPhaseIndex) {
                case 0:
                    return phase0;

                case 1:
                    return phase1;

                case 2:
                    return phase2;

                case 3:
                    return phase3;

                case 4:
                    return phase4;

                case 5:
                    return phase5;

                case 6:
                    return phase6;

            }
        }

        worldObjects.push(this);
    }


    // Returns the distance between two points
    function CalculateDistance(x1, y1, x2, y2) {
        var a = x1 - x2;
        var b = y1 - y2;

        return Math.sqrt(a * a + b * b);
    }



    function GoldObject(x, y) {

        this.x = x;
        this.y = y;

        this.update = function (tickDelta, ctx) {

            if (isWorldScrolling) this.y += 0.5;

            // Destroy this object if it is outside the bounds of the world
            if (this.y > gameHeight) {
                worldObjects.splice(worldObjects.indexOf(this), 1);
                return;
            }

            let distanceToPlayer = CalculateDistance(this.x, this.y, myGamePiece.x, myGamePiece.y);

            if (distanceToPlayer < 20) {

                CollectGold(1);

                // Destroy this object
                worldObjects.splice(worldObjects.indexOf(this), 1);
            }

            let side = 0;
            let size = 20;

            ctx.beginPath();
            ctx.moveTo(this.x + size * Math.cos(0), this.y + size * Math.sin(0));

            for (side; side < 7; side++) {
                ctx.lineTo(this.x + size * Math.cos(side * 2 * Math.PI / 6), this.y + size * Math.sin(side * 2 * Math.PI / 6));
            }

            ctx.fillStyle = "#ffb600";
            ctx.fill();

        }

    }


    function HealObject(x, y) {

        this.x = x;
        this.y = y;

        this.update = function (tickDelta, ctx) {

            if (isWorldScrolling) this.y += 0.5;

            // Destroy this object if it is outside the bounds of the world
            if (this.y > gameHeight) {
                worldObjects.splice(worldObjects.indexOf(this), 1);
                return;
            }

            let distanceToPlayer = CalculateDistance(this.x, this.y, myGamePiece.x, myGamePiece.y);

            if (distanceToPlayer < 20) {

                HealPlayer(maxHealth);

                // Destroy this object
                worldObjects.splice(worldObjects.indexOf(this), 1);
            }

            let side = 0;
            let size = 10;

            ctx.beginPath();
            ctx.moveTo(this.x + size * Math.cos(0), this.y + size * Math.sin(0));

            for (side; side < 7; side++) {
                ctx.lineTo(this.x + size * Math.cos(side * 2 * Math.PI / 6), this.y + size * Math.sin(side * 2 * Math.PI / 6));
            }

            ctx.fillStyle = "#2cff00";
            ctx.fill();


        }

    }

    function Enemy(x, y, size, damage, speed) {

        this.x = x;
        this.y = y;

        this.update = function (tickDelta, ctx) {

            if (this.y > gameHeight) {
                // Destroy this object if it is outside the bounds of the world
                worldObjects.splice(worldObjects.indexOf(this), 1);
                return;
            }

            let distanceToPlayer = CalculateDistance(this.x, this.y, myGamePiece.x, myGamePiece.y);

            if (distanceToPlayer < size) {

                HitPlayer(damage);

                // Destroy this object
                worldObjects.splice(worldObjects.indexOf(this), 1);
            }

            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.moveTo(this.x - size, this.y + size);
            ctx.lineTo(this.x - (size / 2), this.y + size * 2);
            ctx.lineTo(this.x, this.y + size);
            ctx.fill();

            if (isWorldScrolling) this.y += tickDelta * speed;


        }

    }


    // A star is an aesthetic object
    function Star(x, y, radius) {

        this.radius = radius;

        this.x = x;
        this.y = y;
        this.z = 1;

        this.update = function (tickDelta, context) {

            if (this.y > gameHeight) {
                // Destroy this object
                worldObjects.splice(worldObjects.indexOf(this), 1);
                return;
            }

            // Update position
            if (isWorldScrolling) this.y += tickDelta / 2;

            let cercle = new Path2D();
            cercle.arc(this.x, this.y, radius, 0, 2 * Math.PI);

            context.fillStyle = "white";
            context.fill(cercle);

        }
    }

    var dialogFont = "";
    var dialogColor = "";
    var dialogText = "";

    function setDialog(text, color, font) {
        this.dialogText = font;
        this.dialogColor = color;
        this.dialogText = text;
    }

    function clearDialog() {
        this.dialogText = "";
    }

    function drawDialogView(ctx) {

        if (dialogText) {
            ctx.beginPath();

            ctx.textAlign = "center";
            ctx.fillStyle = dialogColor;
            ctx.font = dialogFont;
            ctx.fillText(dialogText, gameWidth / 2, gameHeight - 20);
        }

    }

    let lastUpdateTime = 0;

    let beginRender = new Date();


    window.addEventListener('keyup', function (event) {
        if (event.defaultPrevented) {
            return;
        }

        var key = event.key || event.keyCode;

        if (key === 'Escape' || key === 'Esc' || key === 'Space') {
            console.log("Pausing game");
            isGamePaused = !isGamePaused;

            if (isGamePaused) {
                ShowCursor(true);
                music.pause();
            } else {
                ShowCursor(false);
                music.play();
            }

        }

        if (key === 'a') {
            console.log("Skipping this phase");
            phaseHandler.nextPhase(0);
        }
    });

    // Updates the game
    function updateGameArea() {

        const context = myGameArea.context;

        if (isGamePaused) {
            return;
        }

        myGameArea.clear();


        if (!isGameStarted) {
            return;
        }


        if (myGameArea.x && myGameArea.y) {
            myGamePiece.x = myGameArea.x;
            myGamePiece.y = myGameArea.y;
        }

        if (goldCoinsText && scoreCountText) {
            goldCoinsText.setText("Gold : " + gold);
            scoreCountText.setText("Score : " + score);
        }


        if (lastUpdateTime === 2) {
            console.log("Updating " + worldObjects.length + " objects with time delta " + lastUpdateTime);
        }

        if (gameEnd) {

            context.beginPath();

            context.textAlign = "center";
            context.fillStyle = "red";
            context.font = "20px Arial";
            context.fillText("GAME OVER", gameWidth / 2, gameHeight / 2 - 20);

            context.font = "13px Arial";
            context.fillText("Score : " + score, gameWidth / 2, gameHeight / 2);

            return;
        }


        worldObjects.forEach(element => {
                //console.log("Updating " + element);
                element.update(lastUpdateTime, context);

                // Clear the graph path before repainting
                myGameArea.context.beginPath();
            }
        );

        // Draw the game object on top of everything else
        myGamePiece.update(lastUpdateTime, context);

        drawDialogView(context);

        const endRender = new Date();
        lastUpdateTime = (endRender.getMilliseconds() - beginRender.getMilliseconds()) / gameUpdateRate;

        if (lastUpdateTime < 0) {
            lastUpdateTime = 0;
        }

        //console.log("render : " + endRender.getMilliseconds() + ", " + beginRender.getMilliseconds())

        beginRender = new Date();

    }

</script>

</body>
</html>